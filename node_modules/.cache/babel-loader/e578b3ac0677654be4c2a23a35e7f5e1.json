{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define(\"ReallySmoothScroll\", [], factory);else if (typeof exports === 'object') exports[\"ReallySmoothScroll\"] = factory();else root[\"ReallySmoothScroll\"] = factory();\n})(this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId])\n          /******/\n          return installedModules[moduleId].exports;\n        /******/\n\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n        var module = installedModules[moduleId] = {\n          /******/\n          exports: {},\n\n          /******/\n          id: moduleId,\n\n          /******/\n          loaded: false\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.loaded = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n      __webpack_require__.p = \"build/\";\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(0);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      var SmoothScroll = __webpack_require__(1);\n\n      var spring = __webpack_require__(9);\n\n      var mousewheelSensitivity = 6;\n      var keydownSensitivity = 6;\n      var forceStop = false;\n\n      function getSpringVal(val) {\n        if (typeof val === 'number') return val;\n        return val.val;\n      }\n\n      function stayInRange(min, max, value) {\n        return Math.min(max, Math.max(min, value));\n      }\n\n      function difference(a, b) {\n        return Math.abs(a - b);\n      }\n\n      var moving = false;\n      var scrollY = spring(0);\n      var smoothScroll = new SmoothScroll({\n        style: {\n          scrollY: 0\n        },\n        defaultStyle: {\n          scrollY: 0\n        },\n        onRest: function onRest() {\n          moving = false;\n        }\n      });\n\n      function move(deltaY) {\n        if (!moving) {\n          if (difference(getSpringVal(scrollY), Math.round(window.scrollY)) > 4) {\n            scrollY = window.scrollY;\n            smoothScroll.componentWillReceiveProps({\n              style: {\n                scrollY: scrollY\n              }\n            });\n          }\n\n          moving = true;\n        }\n\n        if (document.querySelector('html').style.overflowY === 'hidden') {\n          return;\n        }\n\n        scrollY = stayInRange(0, document.querySelector('html').offsetHeight - window.innerHeight, // getSpringVal(scrollY) + deltaY\n        window.scrollY + deltaY * mousewheelSensitivity);\n        window.scrollTo(window.scrollX, scrollY);\n      }\n\n      function onkeydown(e) {\n        if (e.target === document.body && e.key === 'ArrowDown') {\n          e.preventDefault();\n          move(keydownSensitivity * 3);\n        } else if (e.target === document.body && e.key === 'ArrowUp') {\n          e.preventDefault();\n          move(-keydownSensitivity * 3);\n        }\n      }\n\n      var mousewheelTimeout = void 0;\n      var maxDeltaY = 0;\n\n      function onmousewheel(e) {\n        var deltaY = stayInRange(-50, 50, e.deltaY);\n\n        if (maxDeltaY === 0 || !forceStop) {\n          maxDeltaY = deltaY; // console.log('Set maxDeltaY');\n        }\n\n        if (document.body.contains(e.target) || e.target === document.body) {\n          e.preventDefault();\n\n          if (forceStop) {\n            // console.log(Math.abs(maxDeltaY), Math.abs(deltaY));\n            if (Math.abs(maxDeltaY) < Math.abs(deltaY) || maxDeltaY * deltaY < 0) {\n              // console.log('Should disable forceStop now 2');\n              forceStop = false;\n            } else {\n              maxDeltaY = deltaY;\n            }\n\n            if (mousewheelTimeout) clearTimeout(mousewheelTimeout);\n            mousewheelTimeout = setTimeout(function () {\n              // console.log('Should disable forceStop now');\n              forceStop = false;\n              maxDeltaY = 0;\n            }, 100);\n            return;\n          } // console.log('Wheeling', forceStop);\n\n\n          move(deltaY);\n        }\n      }\n\n      window._scrollTo = window.scrollTo.bind(window);\n\n      exports.shim = function shim() {\n        window.addEventListener('wheel', onmousewheel);\n        window.addEventListener('keydown', onkeydown);\n\n        if (!window.oldScrollTo) {\n          window.oldScrollTo = function () {\n            if (moving) {\n              window.stopScrolling();\n            }\n\n            smoothScroll.componentWillReceiveProps({\n              style: {\n                scrollY: arguments.length <= 1 ? undefined : arguments[1]\n              }\n            });\n          };\n\n          window.scrollTo = function (x, y) {\n            window._scrollTo(x, window.scrollY);\n\n            smoothScroll.componentWillReceiveProps({\n              style: {\n                scrollY: spring(y)\n              }\n            });\n          };\n        }\n\n        window.stopScrolling = function () {\n          forceStop = true;\n          smoothScroll.componentWillReceiveProps({\n            style: {\n              scrollY: window.scrollY\n            }\n          });\n        };\n      };\n\n      exports.config = function config(options) {\n        if (options.mousewheelSensitivity) {\n          mousewheelSensitivity = options.mousewheelSensitivity;\n        }\n\n        if (options.keydownSensitivity) {\n          keydownSensitivity = options.keydownSensitivity;\n        }\n      };\n      /***/\n\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      var _slicedToArray = function () {\n        function sliceIterator(arr, i) {\n          var _arr = [];\n          var _n = true;\n          var _d = false;\n          var _e = undefined;\n\n          try {\n            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n              _arr.push(_s.value);\n\n              if (i && _arr.length === i) break;\n            }\n          } catch (err) {\n            _d = true;\n            _e = err;\n          } finally {\n            try {\n              if (!_n && _i[\"return\"]) _i[\"return\"]();\n            } finally {\n              if (_d) throw _e;\n            }\n          }\n\n          return _arr;\n        }\n\n        return function (arr, i) {\n          if (Array.isArray(arr)) {\n            return arr;\n          } else if (Symbol.iterator in Object(arr)) {\n            return sliceIterator(arr, i);\n          } else {\n            throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n          }\n        };\n      }();\n\n      var _extends = Object.assign || function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n      var _createClass = function () {\n        function defineProperties(target, props) {\n          for (var i = 0; i < props.length; i++) {\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, descriptor.key, descriptor);\n          }\n        }\n\n        return function (Constructor, protoProps, staticProps) {\n          if (protoProps) defineProperties(Constructor.prototype, protoProps);\n          if (staticProps) defineProperties(Constructor, staticProps);\n          return Constructor;\n        };\n      }();\n\n      function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) {\n          throw new TypeError(\"Cannot call a class as a function\");\n        }\n      }\n\n      var mapToZero = __webpack_require__(2);\n\n      var stripStyle = __webpack_require__(3);\n\n      var stepper = __webpack_require__(4);\n\n      var defaultNow = __webpack_require__(5);\n\n      var defaultRaf = __webpack_require__(7);\n\n      var shouldStopAnimation = __webpack_require__(8);\n\n      var msPerFrame = 1000 / 60;\n\n      module.exports = function () {\n        function SmoothScroll(props) {\n          var _this = this;\n\n          _classCallCheck(this, SmoothScroll);\n\n          this.clearUnreadPropStyle = function (destStyle) {\n            var dirty = false;\n            var _state = _this.state,\n                currentStyle = _state.currentStyle,\n                currentVelocity = _state.currentVelocity,\n                lastIdealStyle = _state.lastIdealStyle,\n                lastIdealVelocity = _state.lastIdealVelocity;\n\n            for (var key in destStyle) {\n              if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {\n                continue;\n              }\n\n              var styleValue = destStyle[key];\n\n              if (typeof styleValue === 'number') {\n                if (!dirty) {\n                  dirty = true;\n                  currentStyle = _extends({}, currentStyle);\n                  currentVelocity = _extends({}, currentVelocity);\n                  lastIdealStyle = _extends({}, lastIdealStyle);\n                  lastIdealVelocity = _extends({}, lastIdealVelocity);\n                }\n\n                currentStyle[key] = styleValue;\n                currentVelocity[key] = 0;\n                lastIdealStyle[key] = styleValue;\n                lastIdealVelocity[key] = 0;\n              }\n            }\n\n            if (dirty) {\n              _this.setState({\n                currentStyle: currentStyle,\n                currentVelocity: currentVelocity,\n                lastIdealStyle: lastIdealStyle,\n                lastIdealVelocity: lastIdealVelocity\n              });\n            }\n          };\n\n          this.startAnimationIfNecessary = function () {\n            // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and\n            // call cb? No, otherwise accidental parent rerender causes cb trigger\n            _this.animationID = defaultRaf(function (timestamp) {\n              // check if we need to animate in the first place\n              var propsStyle = _this.props.style;\n\n              if (shouldStopAnimation(_this.state.currentStyle, propsStyle, _this.state.currentVelocity)) {\n                if (_this.wasAnimating && _this.props.onRest) {\n                  _this.props.onRest();\n                } // no need to cancel animationID here; shouldn't have any in flight\n\n\n                _this.animationID = null;\n                _this.wasAnimating = false;\n                _this.accumulatedTime = 0;\n                return;\n              }\n\n              _this.wasAnimating = true;\n              var currentTime = timestamp || defaultNow();\n              var timeDelta = currentTime - _this.prevTime;\n              _this.prevTime = currentTime;\n              _this.accumulatedTime = _this.accumulatedTime + timeDelta; // more than 10 frames? prolly switched browser tab. Restart\n\n              if (_this.accumulatedTime > msPerFrame * 10) {\n                _this.accumulatedTime = 0;\n              }\n\n              if (_this.accumulatedTime === 0) {\n                // no need to cancel animationID here; shouldn't have any in flight\n                _this.animationID = null;\n\n                _this.startAnimationIfNecessary();\n\n                return;\n              }\n\n              var currentFrameCompletion = (_this.accumulatedTime - Math.floor(_this.accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame;\n              var framesToCatchUp = Math.floor(_this.accumulatedTime / msPerFrame);\n              var newLastIdealStyle = {};\n              var newLastIdealVelocity = {};\n              var newCurrentStyle = {};\n              var newCurrentVelocity = {};\n\n              for (var key in propsStyle) {\n                if (!Object.prototype.hasOwnProperty.call(propsStyle, key)) {\n                  continue;\n                }\n\n                var styleValue = propsStyle[key];\n\n                if (typeof styleValue === 'number') {\n                  newCurrentStyle[key] = styleValue;\n                  newCurrentVelocity[key] = 0;\n                  newLastIdealStyle[key] = styleValue;\n                  newLastIdealVelocity[key] = 0;\n                } else {\n                  var newLastIdealStyleValue = _this.state.lastIdealStyle[key];\n                  var newLastIdealVelocityValue = _this.state.lastIdealVelocity[key];\n\n                  for (var i = 0; i < framesToCatchUp; i++) {\n                    var _stepper = stepper(msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);\n\n                    var _stepper2 = _slicedToArray(_stepper, 2);\n\n                    newLastIdealStyleValue = _stepper2[0];\n                    newLastIdealVelocityValue = _stepper2[1];\n                  }\n\n                  var _stepper3 = stepper(msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision),\n                      _stepper4 = _slicedToArray(_stepper3, 2),\n                      nextIdealX = _stepper4[0],\n                      nextIdealV = _stepper4[1];\n\n                  newCurrentStyle[key] = newLastIdealStyleValue + (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;\n                  newCurrentVelocity[key] = newLastIdealVelocityValue + (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;\n                  newLastIdealStyle[key] = newLastIdealStyleValue;\n                  newLastIdealVelocity[key] = newLastIdealVelocityValue;\n                }\n              }\n\n              _this.animationID = null; // the amount we're looped over above\n\n              _this.accumulatedTime -= framesToCatchUp * msPerFrame;\n\n              _this.setState({\n                currentStyle: newCurrentStyle,\n                currentVelocity: newCurrentVelocity,\n                lastIdealStyle: newLastIdealStyle,\n                lastIdealVelocity: newLastIdealVelocity\n              });\n\n              _this.unreadPropStyle = null;\n\n              _this.startAnimationIfNecessary();\n            });\n          };\n\n          this.wasAnimating = false;\n          this.animationID = null;\n          this.prevTime = 0;\n          this.accumulatedTime = 0; // it's possible that currentStyle's value is stale: if props is immediately\n          // changed from 0 to 400 to spring(0) again, the async currentStyle is still\n          // at 0 (didn't have time to tick and interpolate even once). If we naively\n          // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).\n          // In reality currentStyle should be 400\n\n          this.unreadPropStyle = null; // after checking for unreadPropStyle != null, we manually go set the\n          // non-interpolating values (those that are a number, without a spring\n          // config)\n\n          this.props = props;\n          this.state = this.defaultState();\n          this.prevTime = defaultNow();\n          this.startAnimationIfNecessary();\n        }\n\n        _createClass(SmoothScroll, [{\n          key: 'defaultState',\n          value: function defaultState() {\n            var _props = this.props,\n                defaultStyle = _props.defaultStyle,\n                style = _props.style;\n            var currentStyle = defaultStyle || stripStyle(style);\n            var currentVelocity = mapToZero(currentStyle);\n            return {\n              currentStyle: currentStyle,\n              currentVelocity: currentVelocity,\n              lastIdealStyle: currentStyle,\n              lastIdealVelocity: currentVelocity\n            };\n          }\n        }, {\n          key: 'componentWillReceiveProps',\n          value: function componentWillReceiveProps(nextProps) {\n            if (this.unreadPropStyle != null) {\n              // previous props haven't had the chance to be set yet; set them here\n              this.clearUnreadPropStyle(this.unreadPropStyle);\n            }\n\n            this.unreadPropStyle = nextProps.style;\n\n            if (this.animationID == null) {\n              this.prevTime = defaultNow();\n              this.startAnimationIfNecessary();\n            }\n\n            this.props = _extends({}, this.props, nextProps);\n          }\n        }, {\n          key: 'setState',\n          value: function setState(newState) {\n            this.state = _extends({}, this.state, newState);\n\n            window._scrollTo(window.scrollX, this.state.currentStyle.scrollY);\n          }\n        }]);\n\n        return SmoothScroll;\n      }();\n      /***/\n\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports) {\n      \"use strict\"; // currently used to initiate the velocity style object to 0\n\n      module.exports = function mapToZero(obj) {\n        var ret = {};\n\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            ret[key] = 0;\n          }\n        }\n\n        return ret;\n      };\n      /***/\n\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports) {\n      'use strict';\n      /* @flow */\n      // turn {x: {val: 1, stiffness: 1, damping: 2}, y: 2} generated by\n      // `{x: spring(1, {stiffness: 1, damping: 2}), y: 2}` into {x: 1, y: 2}\n\n      module.exports = function stripStyle(style) {\n        var ret = {};\n\n        for (var key in style) {\n          if (!Object.prototype.hasOwnProperty.call(style, key)) {\n            continue;\n          }\n\n          ret[key] = typeof style[key] === 'number' ? style[key] : style[key].val;\n        }\n\n        return ret;\n      };\n      /***/\n\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports) {\n      \"use strict\";\n      /* @flow */\n      // stepper is used a lot. Saves allocation to return the same array wrapper.\n      // This is fine and danger-free against mutations because the callsite\n      // immediately destructures it and gets the numbers inside without passing the\n      // array reference around.\n\n      var reusedTuple = [0, 0];\n\n      module.exports = function stepper(secondPerFrame, x, v, destX, k, b, precision) {\n        // Spring stiffness, in kg / s^2\n        // for animations, destX is really spring length (spring at rest). initial\n        // position is considered as the stretched/compressed position of a spring\n        var Fspring = -k * (x - destX); // Damping, in kg / s\n\n        var Fdamper = -b * v; // usually we put mass here, but for animation purposes, specifying mass is a\n        // bit redundant. you could simply adjust k and b accordingly\n        // let a = (Fspring + Fdamper) / mass;\n\n        var a = Fspring + Fdamper;\n        var newV = v + a * secondPerFrame;\n        var newX = x + newV * secondPerFrame;\n\n        if (Math.abs(newV) < precision && Math.abs(newX - destX) < precision) {\n          reusedTuple[0] = destX;\n          reusedTuple[1] = 0;\n          return reusedTuple;\n        }\n\n        reusedTuple[0] = newX;\n        reusedTuple[1] = newV;\n        return reusedTuple;\n      };\n      /***/\n\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (process) {\n        \"use strict\"; // Generated by CoffeeScript 1.12.2\n\n        (function () {\n          var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;\n\n          if (typeof performance !== \"undefined\" && performance !== null && performance.now) {\n            module.exports = function () {\n              return performance.now();\n            };\n          } else if (typeof process !== \"undefined\" && process !== null && process.hrtime) {\n            module.exports = function () {\n              return (getNanoSeconds() - nodeLoadTime) / 1e6;\n            };\n\n            hrtime = process.hrtime;\n\n            getNanoSeconds = function getNanoSeconds() {\n              var hr;\n              hr = hrtime();\n              return hr[0] * 1e9 + hr[1];\n            };\n\n            moduleLoadTime = getNanoSeconds();\n            upTime = process.uptime() * 1e9;\n            nodeLoadTime = moduleLoadTime - upTime;\n          } else if (Date.now) {\n            module.exports = function () {\n              return Date.now() - loadTime;\n            };\n\n            loadTime = Date.now();\n          } else {\n            module.exports = function () {\n              return new Date().getTime() - loadTime;\n            };\n\n            loadTime = new Date().getTime();\n          }\n        }).call(undefined);\n        /* WEBPACK VAR INJECTION */\n      }).call(exports, __webpack_require__(6));\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports) {\n      'use strict'; // shim for using process in browser\n\n      var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it\n      // don't break things.  But we need to wrap it in a try catch in case it is\n      // wrapped in strict mode code which doesn't define any globals.  It's inside a\n      // function because try/catches deoptimize in certain engines.\n\n      var cachedSetTimeout;\n      var cachedClearTimeout;\n\n      function defaultSetTimout() {\n        throw new Error('setTimeout has not been defined');\n      }\n\n      function defaultClearTimeout() {\n        throw new Error('clearTimeout has not been defined');\n      }\n\n      (function () {\n        try {\n          if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n          } else {\n            cachedSetTimeout = defaultSetTimout;\n          }\n        } catch (e) {\n          cachedSetTimeout = defaultSetTimout;\n        }\n\n        try {\n          if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n          } else {\n            cachedClearTimeout = defaultClearTimeout;\n          }\n        } catch (e) {\n          cachedClearTimeout = defaultClearTimeout;\n        }\n      })();\n\n      function runTimeout(fun) {\n        if (cachedSetTimeout === setTimeout) {\n          //normal enviroments in sane situations\n          return setTimeout(fun, 0);\n        } // if setTimeout wasn't available but was latter defined\n\n\n        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n          cachedSetTimeout = setTimeout;\n          return setTimeout(fun, 0);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedSetTimeout(fun, 0);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n          }\n        }\n      }\n\n      function runClearTimeout(marker) {\n        if (cachedClearTimeout === clearTimeout) {\n          //normal enviroments in sane situations\n          return clearTimeout(marker);\n        } // if clearTimeout wasn't available but was latter defined\n\n\n        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n          cachedClearTimeout = clearTimeout;\n          return clearTimeout(marker);\n        }\n\n        try {\n          // when when somebody has screwed with setTimeout but no I.E. maddness\n          return cachedClearTimeout(marker);\n        } catch (e) {\n          try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n          } catch (e) {\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n          }\n        }\n      }\n\n      var queue = [];\n      var draining = false;\n      var currentQueue;\n      var queueIndex = -1;\n\n      function cleanUpNextTick() {\n        if (!draining || !currentQueue) {\n          return;\n        }\n\n        draining = false;\n\n        if (currentQueue.length) {\n          queue = currentQueue.concat(queue);\n        } else {\n          queueIndex = -1;\n        }\n\n        if (queue.length) {\n          drainQueue();\n        }\n      }\n\n      function drainQueue() {\n        if (draining) {\n          return;\n        }\n\n        var timeout = runTimeout(cleanUpNextTick);\n        draining = true;\n        var len = queue.length;\n\n        while (len) {\n          currentQueue = queue;\n          queue = [];\n\n          while (++queueIndex < len) {\n            if (currentQueue) {\n              currentQueue[queueIndex].run();\n            }\n          }\n\n          queueIndex = -1;\n          len = queue.length;\n        }\n\n        currentQueue = null;\n        draining = false;\n        runClearTimeout(timeout);\n      }\n\n      process.nextTick = function (fun) {\n        var args = new Array(arguments.length - 1);\n\n        if (arguments.length > 1) {\n          for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n          }\n        }\n\n        queue.push(new Item(fun, args));\n\n        if (queue.length === 1 && !draining) {\n          runTimeout(drainQueue);\n        }\n      }; // v8 likes predictible objects\n\n\n      function Item(fun, array) {\n        this.fun = fun;\n        this.array = array;\n      }\n\n      Item.prototype.run = function () {\n        this.fun.apply(null, this.array);\n      };\n\n      process.title = 'browser';\n      process.browser = true;\n      process.env = {};\n      process.argv = [];\n      process.version = ''; // empty string to avoid regexp issues\n\n      process.versions = {};\n\n      function noop() {}\n\n      process.on = noop;\n      process.addListener = noop;\n      process.once = noop;\n      process.off = noop;\n      process.removeListener = noop;\n      process.removeAllListeners = noop;\n      process.emit = noop;\n      process.prependListener = noop;\n      process.prependOnceListener = noop;\n\n      process.listeners = function (name) {\n        return [];\n      };\n\n      process.binding = function (name) {\n        throw new Error('process.binding is not supported');\n      };\n\n      process.cwd = function () {\n        return '/';\n      };\n\n      process.chdir = function (dir) {\n        throw new Error('process.chdir is not supported');\n      };\n\n      process.umask = function () {\n        return 0;\n      };\n      /***/\n\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      /* WEBPACK VAR INJECTION */\n      (function (global) {\n        'use strict';\n\n        var now = __webpack_require__(5),\n            root = typeof window === 'undefined' ? global : window,\n            vendors = ['moz', 'webkit'],\n            suffix = 'AnimationFrame',\n            raf = root['request' + suffix],\n            caf = root['cancel' + suffix] || root['cancelRequest' + suffix];\n\n        for (var i = 0; !raf && i < vendors.length; i++) {\n          raf = root[vendors[i] + 'Request' + suffix];\n          caf = root[vendors[i] + 'Cancel' + suffix] || root[vendors[i] + 'CancelRequest' + suffix];\n        } // Some versions of FF have rAF but not cAF\n\n\n        if (!raf || !caf) {\n          var last = 0,\n              id = 0,\n              queue = [],\n              frameDuration = 1000 / 60;\n\n          raf = function raf(callback) {\n            if (queue.length === 0) {\n              var _now = now(),\n                  next = Math.max(0, frameDuration - (_now - last));\n\n              last = next + _now;\n              setTimeout(function () {\n                var cp = queue.slice(0); // Clear queue here to prevent\n                // callbacks from appending listeners\n                // to the current frame's queue\n\n                queue.length = 0;\n\n                for (var i = 0; i < cp.length; i++) {\n                  if (!cp[i].cancelled) {\n                    try {\n                      cp[i].callback(last);\n                    } catch (e) {\n                      setTimeout(function () {\n                        throw e;\n                      }, 0);\n                    }\n                  }\n                }\n              }, Math.round(next));\n            }\n\n            queue.push({\n              handle: ++id,\n              callback: callback,\n              cancelled: false\n            });\n            return id;\n          };\n\n          caf = function caf(handle) {\n            for (var i = 0; i < queue.length; i++) {\n              if (queue[i].handle === handle) {\n                queue[i].cancelled = true;\n              }\n            }\n          };\n        }\n\n        module.exports = function (fn) {\n          // Wrap in a new function to prevent\n          // `cancel` potentially being assigned\n          // to the native rAF function\n          return raf.call(root, fn);\n        };\n\n        module.exports.cancel = function () {\n          caf.apply(root, arguments);\n        };\n\n        module.exports.polyfill = function () {\n          root.requestAnimationFrame = raf;\n          root.cancelAnimationFrame = caf;\n        };\n        /* WEBPACK VAR INJECTION */\n\n      }).call(exports, function () {\n        return this;\n      }());\n      /***/\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports) {\n      'use strict'; // usage assumption: currentStyle values have already been rendered but it says\n      // nothing of whether currentStyle is stale (see unreadPropStyle)\n\n      module.exports = function shouldStopAnimation(currentStyle, style, currentVelocity) {\n        for (var key in style) {\n          if (!Object.prototype.hasOwnProperty.call(style, key)) {\n            continue;\n          }\n\n          if (currentVelocity[key] !== 0) {\n            return false;\n          }\n\n          var styleValue = typeof style[key] === 'number' ? style[key] : style[key].val; // stepper will have already taken care of rounding precision errors, so\n          // won't have such thing as 0.9999 !=== 1\n\n          if (currentStyle[key] !== styleValue) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n      /***/\n\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      'use strict';\n\n      var _extends = Object.assign || function (target) {\n        for (var i = 1; i < arguments.length; i++) {\n          var source = arguments[i];\n\n          for (var key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n              target[key] = source[key];\n            }\n          }\n        }\n\n        return target;\n      };\n\n      var presets = __webpack_require__(10);\n\n      var defaultConfig = _extends({}, presets.noWobble, {\n        precision: 0.01\n      });\n\n      module.exports = function spring(val, config) {\n        return _extends({}, defaultConfig, config, {\n          val: val\n        });\n      };\n      /***/\n\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports) {\n      \"use strict\";\n\n      module.exports = {\n        noWobble: {\n          stiffness: 170,\n          damping: 26\n        },\n        // the default, if nothing provided\n        gentle: {\n          stiffness: 120,\n          damping: 14\n        },\n        wobbly: {\n          stiffness: 180,\n          damping: 12\n        },\n        stiff: {\n          stiffness: 210,\n          damping: 20\n        }\n      };\n      /***/\n    }])\n  );\n});\n\n;","map":null,"metadata":{},"sourceType":"script"}